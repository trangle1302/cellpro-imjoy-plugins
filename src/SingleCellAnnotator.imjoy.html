<docs lang="markdown">
[TODO: write documentation for this plugin.]
</docs>

<config lang="json">
{
  "name": "SingleCellAnnotator",
  "type": "window",
  "tags": [],
  "ui": "",
  "version": "0.1.23",
  "api_version": "0.1.7",
  "description": "Annotate images for HPA single-cell image classification",
  "icon": "extension",
  "inputs": null,
  "outputs": null,
  "env": "",
  "permissions": [],
  "requirements": [
      "https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.min.js",
      "https://static.imjoy.io/spectre.css/spectre.min.css",
      "https://static.imjoy.io/spectre.css/spectre-exp.min.css",
      "https://static.imjoy.io/spectre.css/spectre-icons.min.css",
      "https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.1.1/css/ol.css",
      "https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.1.1/build/ol.js"
  ],
  "dependencies": [],
  "defaults": {"fullscreen": true},
  "runnable": true
}
</config>

<script lang="javascript">
const servers = {
  'development': 'https://wet-grasshopper-41.telebit.io',
  'production': 'https://unlucky-shrimp-3.telebit.io',
  'localhost': 'http://127.0.0.1:5000'
}

const Map = ol.Map;
const View = ol.View;
const Draw = ol.interaction.Draw;
const Modify = ol.interaction.Modify;
const Select = ol.interaction.Select;
const defaultInteractions = ol.interaction.defaults;
const TileLayer = ol.layer.Tile;
const Style = ol.style.Style;
const Fill = ol.style.Fill;
const Stroke = ol.style.Stroke;
const Text = ol.style.Text;
const VectorLayer = ol.layer.Vector;
const OSM = ol.source.OSM;
const VectorSource = ol.source.Vector;
const MousePosition = ol.control.MousePosition;
const LayerSwitcher = ol.control.LayerSwitcher;
const Zoomify = ol.source.Zoomify;
const Static = ol.source.ImageStatic;
const ImageLayer = ol.layer.Image;
const Projection = ol.proj.Projection;
const createStringXY = ol.coordinate.createStringXY;
const DragAndDrop = ol.interaction.DragAndDrop;
const GeoJSON = ol.format.GeoJSON;
const RasterSource = ol.source.Raster;
const getWidth = ol.extent.getWidth;
const getCenter = ol.extent.getCenter;
const Layer = ol.layer.Layer;
const fromLonLat = ol.proj.fromLonLat;
const toLonLat = ol.proj.toLonLat;
const CircleStyle = ol.style.Circle;
const Snap = ol.interaction.Snap;
const defaultControls = ol.control.defaults;

function mobileAndTabletcheck() {
  var check = false;
  (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera);
  return check;
};

async function getImageData(url) {
  return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas')
        canvas.width = img.width
        canvas.height = img.height
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0,0);
        const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height).data
        const data = new Uint8Array(new ArrayBuffer(canvas.width * canvas.height))
        for(let i=0;i<canvas.width*canvas.height;i++){
          data[i] = imgData[i*4];
        }
        resolve({data: data, width: canvas.width, height: canvas.height})
      };
      img.onerror = reject;
      img.crossOrigin = "Anonymous";
      img.src = url;
  });
};

const colormap = {'Microtubule': 0, 'Protein': 1, 'ER': 0, 'Nuclei': 2, 'Mask': 3}

async function composeChannels(channels, channel_settings, alpha){
  if(alpha<0) alpha = 0;
  if(alpha>1) alpha = 1;
  const rgb_channels = []
  const canvas = document.createElement('canvas') 
  for(let k in channel_settings){
    if(channels[k] && colormap.hasOwnProperty(k)){
      if(channel_settings[k].show){
        const imgData = await getImageData(channels[k]);
        rgb_channels[colormap[k]] = imgData;
        canvas.width = imgData.width
        canvas.height = imgData.height
      }
    }
    if(!colormap.hasOwnProperty(k)){
      console.warn('No color map defined for ' + k)
    }
  }
  const ctx = canvas.getContext('2d');
  const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height)
  const channel_offset = canvas.width * canvas.height * 4
  let i, j;
  const data = imgData.data
  // set color channels
  for(j=0;j<3;j++){
    if(rgb_channels[j]){
      const src = rgb_channels[j].data;
      for(i=0;i<channel_offset;i++){
          data[i*4+j]  = src[i]
      }
     
    }
  }
  // set alpha channel
  if(rgb_channels[3]){
    const src = rgb_channels[3].data;
    for(i=0;i<channel_offset;i++){
      if(src[i]>0){
        data[i*4+3] = parseInt(alpha*255);
      }
      else{
        data[i*4+3] = 255;
      }
    }
  }
  else{
    for(i=0;i<channel_offset;i++){
      data[i*4+3] = 255; 
    }
  }
  ctx.putImageData(imgData, 0, 0);
  return {url: canvas.toDataURL(), width: canvas.width, height: canvas.height}
}

const imageDataTemplate = {
  extend: null,
  cell_id: null,
  mask_geojson:{
  'type':'FeatureCollection',
  'features':[
    {
      'type':'Feature',
      'geometry':{
      'type':'Polygon',
      'coordinates':null
      },
      'properties':null
    }],
  'bbox':null,
  },
  label_display_mode: null,
  channels: null,
  location: null,
  discarded: false,
  mask_adjusted: false,
  location_changed: false,
};

const app = new Vue({
  el: '#app',
  data: {
    viewProxy: null,
    renderWindow: null,
    interactor: null,
    renderer: null,
    modifyInteraction: null,
    drawInteraction: null,
    snapInteraction: null,
    itkInteraction: null,
    annotation_mode: false,
    freehand_mode: true,
    vector_source: null,
    loading: false,
    // develop image parsing
    selected_server_url: null,
    servers: servers,
    select: null,
    current_panel: 'login',
    user:{
      username: "wei",
      password: "GPq2VZgRg2lq5lYPNh9v",
      access_token: null
    },
    channel_settings: {},
    alpha: 0.5,
  // from here this is communication to backend, to develop/activate
    tasks: null,
    current_task_name: null,
    cell_per_batch: 10,
    loaded_image_list: null,
    cached_image_data: [],
    current_image_data: null,
    current_image_index: 0,
    loading_cache: false,
  },
  mounted(){
    this.selected_server_url = this.servers['production']
    document.addEventListener('keydown', (event)=>{
      if(this.current_panel==='imageviewer'){
        if(event.shiftKey && event.code ==='Equal' || ['+', 'Plus', 'NumpadAdd'].includes(event.code)){
          if(this.alpha<1){
            this.alpha = this.alpha+0.1;
          }
          else{
            this.alpha = 1;
          }
          this.displayMap(this.current_image_data.channels, this.channel_settings);
        }
        else if(['-', 'Minus', 'NumpadSubtract'].includes(event.code)){
          if(this.alpha>0){
            this.alpha = this.alpha-0.1;
          }
          else{
            this.alpha = 0;
          }
          this.displayMap(this.current_image_data.channels, this.channel_settings);
        }
        else if(event.code === 'KeyY'){
          if(this.current_image_data.label_display_mode==='single'){
            this.selectLocation(true)
          }
        }
        else if(event.code === 'KeyN'){
          if(this.current_image_data.label_display_mode==='single'){
            this.selectLocation(false)
          }
        }
        else if(event.code === 'ArrowRight'){
          this.nextImage()
        }
        else if(event.code === 'ArrowLeft'){
          this.previousImage()
        }
        else if(event.code === 'KeyD'){
          this.toggleDiscard()
        }
        else if(event.code === 'KeyM'){
          this.annotation_mode = true
        }
        else if(event.code === 'KeyR'){
          this.removeMaskAnnotation()
        }
        else if(event.code === 'KeyS'){
          this.saveMaskAnnotation()
        }
        else if(event.code === 'Escape'){
          this.home()
        }
        // alpha channel mask
        else if(event.code === 'KeyA'){
          if(this.channel_settings['Mask'].show)
            this.channel_settings['Mask'].show = false;
          else
            this.channel_settings['Mask'].show = true;
        }
        // ER
        else if(event.code === 'KeyE'){
          if(this.channel_settings['ER'].show)
            this.channel_settings['ER'].show = false;
          else
            this.channel_settings['ER'].show = true;
        }
        // Microtubule
        else if(event.code === 'KeyT'){
          if(this.channel_settings['Microtubule'].show)
            this.channel_settings['Microtubule'].show = false;
          else
            this.channel_settings['Microtubule'].show = true;
        }
        // Nuclei
        else if(event.code === 'KeyI'){
          if(this.channel_settings['Nuclei'].show)
            this.channel_settings['Nuclei'].show = false;
          else
            this.channel_settings['Nuclei'].show = true;
        }
        // Protein
        else if(event.code === 'KeyP'){
          if(this.channel_settings['Protein'].show)
            this.channel_settings['Protein'].show = false;
          else
            this.channel_settings['Protein'].show = true;
        }
        this.$forceUpdate()
      }
    })
  },
  methods: {
    async login(){
      const formData = new FormData();
      formData.append('username', this.user.username);
      formData.append('password', this.user.password);
      const response = await fetch(this.selected_server_url + "/login", {
        method: 'POST',
        mode: 'cors',
        body: formData
      })
      if(response.status === 200){
        const res = await response.json()
        if(res.success){
            if(!res.access_token){
              api.alert('JWT access token required, please make sure you are using the latest backend.');
              return
            }
            this.user.access_token = res.access_token
            const response2 = await fetch(this.selected_server_url + "/tasks", {
            method: 'GET',
            headers: {'Authorization': `Bearer ${this.user.access_token}`},
          })
          const res2 = await response2.json()
          this.tasks = res2.tasks
          this.current_panel = 'task_selection';
        }else{
          api.alert('Failed to login, error: ' + res.error);
        }
      }else{
        api.alert('Response Status' + response.status)
      }
    },

    async fetchURLData (sub_url){
      const response = await fetch(this.selected_server_url + sub_url, {
        method: 'GET',
        headers: {'Authorization': `Bearer ${this.user.access_token}`},
      })
      if(response.status === 200){
        const res = await response.json()
        if (res.success){
          return res
        }else{
          api.showMessage('Internal server error: ' + res.error)
          throw 'Internal server error: ' + res.error
        }
      }else{
        api.showMessage('Response Status:' + response.status)
        throw 'Response Status:' + response.status
      }
    },
    async chooseTask (task_name){
      this.current_task_name = task_name;
      this.loading = true;
      this.getNewImageBatch(this.current_task_name, true);
    },
    async fetchCellImage(cell_id, extend_image){
      const imageData = JSON.parse(JSON.stringify(imageDataTemplate));
      imageData.cell_id = cell_id;
      let image_url = "/images/" + this.current_task_name + "/" + imageData.cell_id;
      if (extend_image){
        image_url += "?extend=200&maskout=1";
        imageData.extend = 200;
      }else{
        image_url += "?extend=20&maskout=1"
        imageData.extend = 20;
      }
      const response = await this.fetchURLData(image_url)
      imageData.mask_geojson.bbox = response.bbox;
      const image_coordinates = await this.processCoordinates(response.mask.geometry.coordinates);
      imageData.mask_geojson.features[0].geometry.coordinates = image_coordinates;
      //ER, Microtubule, Nuclei, Protein,
      imageData.channels = response.images;
      locations = Object.keys(response.location);
      if(locations.length==1){
        imageData.label_display_mode = 'single'
        imageData.single_location = locations[0];
        imageData.location = response.location;
      }
      else
      { 
        imageData.label_display_mode = 'multiple'
        imageData.location = response.location;
      }
      return imageData
    },
    async getNewImageBatch(task_name, display_first){
      api.showStatus('Loading a new batch...')
      if(this.loading_cache){
        if(task_name === this.loading_cache){
          return
        }
        else{
          // switch tasks
          this.cached_image_data = []
        }
      }
      try{
        this.loading_cache = task_name;
        const response = await this.fetchURLData("/tasks/" + task_name + "?cell_num=" + this.cell_per_batch);
        this.loaded_image_list  =response.cells;
        if(this.loaded_image_list.length<=0){
          api.showMessage('No more images in this task.')
          return
        }
        for(let i=0;i< this.loaded_image_list.length; i++){
          if(task_name !== this.loading_cache){
            console.error('Switching tasks, quit caching')
            break
          }
          const cell_id = this.loaded_image_list[i];
          api.showProgress((i+1)/this.loaded_image_list.length)
          const imageData = await this.fetchCellImage(cell_id)
          if(display_first && i===0){
            this.showImage(imageData)
            this.$forceUpdate();
          }
          this.cached_image_data.push(imageData)
        }
        // remove older images
        if(this.cached_image_data.length>this.cell_per_batch*3){
          this.cached_image_data = this.cached_image_data.slice(this.cell_per_batch)
          console.log('Removing images from the cache.',  this.cached_image_data.length)
        }
        api.showProgress(100)
        api.showStatus(`A new batch with ${this.loaded_image_list.length} images loaded`)
        this.loadMoreIfNeeded();
      }
      finally{
        this.loading_cache = false;
      }
    },
    async processCoordinates (coordinates){
      // in priniciple, bbox should pass the crop starting points, and do this processing
      var new_coordinates = coordinates[0]
      const length = new_coordinates.length - 1;
      var minx = new_coordinates[length][0];
      var miny = new_coordinates[length][1];
      for (index = 0; index < new_coordinates.length; index++){
        if (minx > new_coordinates[index][0]){minx = new_coordinates[index][0]}
        if (miny > new_coordinates[index][1]){miny = new_coordinates[index][1]}
      };
      for (index = 0; index < new_coordinates.length; index++){
        new_coordinates[index][0] = new_coordinates[index][0] - minx;
        new_coordinates[index][1] = new_coordinates[index][1] - miny;
      };
      return [new_coordinates]
    },
    async previousImage(){
      if(this.annotation_mode){
        const anwser = await api.confirm("Would you like to save the mask annotation?")
        if(anwser){
          this.saveMaskAnnotation()
        }
        this.stopMaskAnnotation();
      };
      this.current_image_index = this.cached_image_data.indexOf(this.current_image_data)
      if(this.current_image_index<=-1){
        this.current_image_index = 0;
      }
      else{
        this.current_image_index--;
      }
      await this.showImage(this.cached_image_data[this.current_image_index]);
    },
    loadMoreIfNeeded(){
      this.current_image_index = this.cached_image_data.indexOf(this.current_image_data)
      // when we reach 70% of the the cached images
      if(this.current_image_index>this.cached_image_data.length*0.7){
        this.getNewImageBatch(this.current_task_name)
      }
    },
    async nextImage(){
      this.loadMoreIfNeeded();
      if(this.annotation_mode){
        const anwser = await api.confirm("Would you like to save the mask annotation?")
        if(anwser){
          this.saveMaskAnnotation()
        }
        this.stopMaskAnnotation();
      }
      if(this.current_image_data.location_changed){
        await this.uploadAnnotation();
      }
      this.current_image_index++;
      if(this.cached_image_data[this.current_image_index])
      await this.showImage(this.cached_image_data[this.current_image_index]);
    },
    async showImage(imageData){
      if(!imageData){
        api.showStatus('No more image to show.')
        console.error('no image data to show.')
        return
      }

      api.showStatus(imageData.cell_id)
      console.log('current image: ', imageData)
      this.current_image_data = imageData;
      // annotation viewer
      this.current_panel = 'imageviewer';
      this.$nextTick(async ()=>{
        this.loading = true;
        try{
            await this.displayMap(this.current_image_data.channels, this.channel_settings);
            this.showMaskAnnotation(this.current_image_data.mask_geojson);
          }
        finally{
          this.loading = false;
        }
      })
    },
    // extend Image
    async extendImage(){
      this.current_image_index = this.cached_image_data.indexOf(this.current_image_data);
      const cell_id = this.current_image_data.cell_id;
      const imageData = await this.fetchCellImage(cell_id, true)
      this.cached_image_data[this.current_image_index] = imageData;
      this.current_image_data = imageData
      await this.showImage(imageData)
      await this.showMaskAnnotation(imageData.mask_geojson);
    },
    async uploadAnnotation(){
      // skip upload annotation if image is annotated and no new change
      if ((!this.current_image_data.mask_adjusted)&&(!this.current_image_data.location_changed)){
        return
      }
      // Default options are marked with *
      const sendData = {}
      sendData.discarded = this.current_image_data.discarded;
      if(!sendData.discarded){
        if(this.current_image_data.location_changed){
          sendData.location = {};
          sendData.location = this.current_image_data.location;
          let noLocation = true;
          for (loc in sendData.location){
            if(sendData.location[loc] === null){
              sendData.location[loc] = false
            }
            else{
              noLocation = false;
            }
          }
          if (noLocation && this.current_image_data.label_display_mode==='multiple'){
            const anwser = await api.confirm("No location label selected, is that correct?")
            if (!anwser){
              return
            }
          };
        }
       
  
        if (this.current_image_data.mask_adjusted){
          sendData.extend = this.current_image_data.extend;
          sendData.bbox = this.current_image_data.mask_geojson.bbox;
          for (item in sendData.bbox){
            sendData.bbox[item] = Number(sendData.bbox[item].toFixed(1))
          };
          sendData.mask = this.current_image_data.mask_geojson.features;
          // now adjust the digit to 1 decimal for cooridinates
          let coordinates = this.current_image_data.mask_geojson.features[0].geometry.coordinates[0]
          for (let index = 0; index < coordinates.length; index++){
            coordinates[index][0] = Number(coordinates[index][0].toFixed(1));
            coordinates[index][1] = Number(coordinates[index][1].toFixed(1));
          };
        }
    
      }
      // this is the url to send the current annotation
      const sub_url = "/annotations/" + this.current_task_name + "/" + this.current_image_data.cell_id;
      const url_post = this.selected_server_url + sub_url;
      const response = await fetch(url_post, {
          method: 'POST',
          mode: 'cors',
          cache: 'no-cache',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${this.user.access_token}`,
          },
          body: JSON.stringify(sendData)
        });
      const res= await response.json();
      if(res.success){
        this.current_image_data.mask_adjusted = false;
        this.current_image_data.location_changed = false;
      }
      else{
        alert('Failed to upload the annotaiton, error: ' + res.error);
        throw new Error('Failed to upload the annotaiton.')
      };
    },
    async annotation_mode_changed(){
      if(this.annotation_mode){
        this.loading = true;
        try{
          this.current_image_data.mask_adjusted=false;
          await this.extendImage();
        }
        finally{
          this.loading = false;
        }
      }
      else{
        this.stopMaskAnnotation()
      }
    },
    async toggleDiscard(){
      if(this.current_image_data.discarded){
        this.current_image_data.discarded = false;
      }
      else{
        this.current_image_data.discarded = true;
        this.annotation_mode = false;
        await this.nextImage();
      }
      this.$forceUpdate()
    },
    async showMaskAnnotation(mask_geojson){
      this.vector_source.clear()
      features = (new GeoJSON()).readFeatures(mask_geojson)
      this.vector_source.addFeatures(features)
    },
    async saveMaskAnnotation(){
      const allFeatures = this.vector_source.getFeatures();
      const format = new ol.format.GeoJSON();
      const routeFeatures = format.writeFeaturesObject(allFeatures, {decimals: 1});
      if (!routeFeatures.features.length){
        api.alert('Please draw a cell mask before saving!');
        return
      }
      if(routeFeatures.features.length>1){
        api.alert('Only one cell mask is allowed!');
        return
      }
      
      routeFeatures['bbox'] = this.current_image_data.mask_geojson.bbox;
      this.current_image_data.mask_geojson = routeFeatures;
      this.current_image_data.mask_adjusted = true;
      await this.uploadAnnotation()
      this.stopMaskAnnotation();
    },
    async exportAnnotation() {
      const allFeatures = this.vector_source.getFeatures();

      const format = new ol.format.GeoJSON();
      const routeFeatures = format.writeFeaturesObject(allFeatures, {decimals: 1});
      routeFeatures['bbox'] = this.current_image_data.mask_geojson.bbox;
      const blob = new Blob([JSON.stringify(routeFeatures)], {
          type: "text/plain;charset=utf-8"
      });
      api.alert(JSON.stringify(blob))
    },
    // go to nextImage after select yes/no.
    async selectLocation(selected){
      this.current_image_data.location[this.current_image_data.single_location] = selected;
      this.current_image_data.location_changed = true;
      await this.nextImage()
    },
    async displayMap(channels, channel_settings){
      for(let k of Object.keys(channels)){
        if(!channel_settings[k]){
          channel_settings[k] = {name: k, show: true}
          // don't show ER by default
          if(k==='ER'){
            channel_settings[k].show = false;
          }
        }
      }
      const image = await composeChannels(channels, channel_settings, this.alpha)
      const extent = [0, 0, image.width, image.height];

      const projection = new Projection({
          code: 'image',
          units: 'pixels',
          extent: extent,
      });

      const image_source = new Static({
        attributions: 'Â©Human Protein Atlas',
        url: image.url,
        projection: projection,
        imageExtent: extent
      })

      if(this.image_layer && this.map){
        this.map.setView( new View({
          projection: projection,
          center: getCenter(extent),
          zoom: 1,
          minZoom: -10
        }))
        this.image_layer.setSource(image_source)
        return
      }

      this.image_layer = new ImageLayer({
        source: image_source,
      })

      this.vector_source = new VectorSource();
      var vector_layer = new VectorLayer({
        source: this.vector_source,
        style: new Style({
          fill: new Fill({
            color: 'rgba(255, 255, 255, 0)'
          }),
          stroke: new Stroke({
            color: '#ffcc33',
            width: 2
          }),
          image: new CircleStyle({
            radius: 7,
            fill: new Fill({
              color: '#ffcc33'
            })
          })
        })
      });
      const select = new Select({
          wrapX: false
      });
      // clear map
      document.getElementById('map').innerHTML = ""
      this.map = new Map({
        interactions: ol.interaction.defaults({altShiftDragRotate:false, pinchRotate:false}),
        controls: [],
        layers: [
          this.image_layer,
          vector_layer,
        ],
        target: 'map',
        view: new View({
          projection: projection,
          center: getCenter(extent),
          zoom: 1,
          minZoom: -10
        })
      });
      this.annotation_mode_changed();
      this.map.addControl(new MousePosition({
          coordinateFormat: createStringXY(0)
      }));
      this.map.addInteraction(select);
      select.on('select', (e) => {
          console.log(e.selected, '&nbsp;' +
              e.target.getFeatures().getLength() +
              ' selected features (last operation selected ' + e.selected.length +
              ' and deselected ' + e.deselected.length + ' features)')
      });
      this.select = select
    },
    removeMaskAnnotation() {
      this.current_image_data.mask_adjusted = true;
      this.vector_source.clear()
      this.startMaskAnnotation(this.vector_source, this.freehand_mode)
    },
    startMaskAnnotation(source, freehand){
      if(!source){
        console.error("Please specify an annotation layer source")
      }
      if (this.modifyInteraction) {
        this.map.removeInteraction(this.modifyInteraction)
      }
      this.modifyInteraction = new Modify({source: source});
      this.map.addInteraction(this.modifyInteraction);
      if (this.drawInteraction) {
        this.map.removeInteraction(this.drawInteraction)
      }
      this.drawInteraction = new Draw({
        source: source,
        type: 'Polygon',
        freehand: freehand
      });
      this.map.addInteraction(this.drawInteraction);
      if (this.snapInteraction) {
        this.map.removeInteraction(this.snapInteraction)
      }
      this.snapInteraction = new Snap({source: source});
      this.map.addInteraction(this.snapInteraction);
      this.annotation_mode = true;
    },
    stopMaskAnnotation(){
      this.annotation_mode = false;
      if(this.drawInteraction)
      this.map.removeInteraction(this.drawInteraction);
      if(this.snapInteraction)
      this.map.removeInteraction(this.snapInteraction);
      if(this.modifyInteraction)
      this.map.removeInteraction(this.modifyInteraction);
    },
    toggleLocation(k){
      if(this.current_image_data.location[k]){
        this.current_image_data.location[k]=false
      }
      else{
        this.current_image_data.location[k]=true
      }
      this.current_image_data.location_changed = true;
    },
    home(){
      this.current_panel='task_selection';
      this.current_task_name=null;
    },
    channelSettingsUpdated(event){
      // make sure ER and Microtubule are not turned on at the same time
      if(event.target.name === 'ER' && event.target.value === 'on'){
        if(this.channel_settings['Microtubule']){
          this.channel_settings['Microtubule'].show = false
        }
      }
      else if(event.target.name === 'Microtubule' && event.target.value === 'on'){
        if(this.channel_settings['ER']){
          this.channel_settings['ER'].show = false
        }
      }
      this.$forceUpdate()
      this.displayMap(this.current_image_data.channels, this.channel_settings);
    }
  }
})

class ImJoyPlugin {
  async setup() {
  }

  async run(ctx) {

  }
}

api.export(new ImJoyPlugin())
</script>

<window>
  <div style="text-align: center;" id="app">

    <div class="panel centered-panel" v-if="current_panel=='login'">
      <div class="panel-header">
        <div class="panel-title h2">Login</div>
      </div>
      <div class="panel-body">
        <div class="form-group">
          <label class="form-label" for="server">Server</label>
          <select class="form-select" v-model="selected_server_url">
            <option>Choose an option</option>
            <option v-for="(url, k) in servers" :value="url">{{k}}</option>
          </select>
        </div>
        <div class="form-group">
          <label class="form-label" for="input-example-1">Name</label>
          <input class="form-input" type="text" name="username" v-model="user.username"  placeholder="username">
        </div>
        <div class="form-group">
          <label class="form-label" for="input-example-1">Password</label>
          <input class="form-input" type="password" name="password" v-model ="user.password" placeholder="password">
        </div>
        <button class="btn" @click="login()">Login</button>
      </div>
      <div class="panel-footer">
        <!-- buttons or inputs -->
      </div>
    </div>


    <div class="panel centered-panel" v-if="current_panel=='task_selection'">
      <div class="panel-header">
        <div class="panel-title h2">Please choose a task</div>
      </div>
      <div class="panel-body">
        <br>
        <br>
        <div v-for="(task, task_name) in tasks">
          <progress class="progress" style="width: 288px" :value="task.finished" :max="task.total"></progress>
          <br>
          <button class="btn" style="width: 280px" @click="chooseTask(task_name)"><i class="icon icon-edit"></i>&nbsp; {{task_name}}: {{task.finished}}/{{task.total}}</button>&nbsp;&nbsp;
          <br>
          <br>
        </div>
      </div>
      <div class="panel-footer">
      </div>
    </div>
  
    <div class="panel" v-if="current_panel=='imageviewer'&&current_image_data">
      <div class="input-group floating-switch">
        <button v-show="!annotation_mode" class="btn" :class="{'transparent-btn': current_image_data.discarded!==true}" @click="toggleDiscard()">Discard</button>&nbsp;&nbsp;
        <label class="form-switch">
          <input type="checkbox" v-model="annotation_mode" @change="annotation_mode_changed">
          <i class="form-icon"></i> <span class="hide-on-mobile">Adjust Mask</span>
        </label>
        <button v-show="current_image_data.mask_adjusted" class="btn transparent-btn" v-if="annotation_mode" @click="saveMaskAnnotation()">Save</button>&nbsp;&nbsp;
        <button class="btn transparent-btn" title="annotation mode" v-if="annotation_mode" @click="removeMaskAnnotation()"><i class="icon icon-delete"></i></button>&nbsp;&nbsp;
        <button class="btn transparent-btn btn-action s-circle" title="home" @click="home()"><i class="icon icon-cross"></i></button>&nbsp;&nbsp;
      </div>
      <div class="form-group floating-channel-btn">
        <label v-for="ch in channel_settings" class="form-checkbox">
          <input v-model="ch.show" :name="ch.name" @change="channelSettingsUpdated" type="checkbox">
          <i class="form-icon"></i> {{ch.name}}
        </label>
      </div>
      <template v-if="current_image_data.label_display_mode==='multiple'">
        <div class="floating-right-btn">
          <div class="btn-group">
            <button :disabled="current_image_index===0||annotation_mode" class="btn transparent-btn" @click="previousImage()"><i class="icon icon-back"></i>&nbsp;Back</button>
            <button :disabled="current_image_index>=cached_image_data.length||annotation_mode" class="btn transparent-btn" @click="nextImage()">Next&nbsp;<i class="icon icon-forward"></i></button>
          </div>
          <br>
          <div class="columns">
            <button :disabled="current_image_data.discarded" v-for="(loc, k) in current_image_data.location" @click="toggleLocation(k)" class="column btn location-btn" :class="{'selected-location-btn': loc}">{{k.slice(0,12)+(k.length>12?'.': '')}}</button>
          </div>
        </div>
      </template>
      <template v-if="current_image_data.label_display_mode==='single'">
        <div class="btn-group floating-bottom-btn">
          <button :disabled="current_image_index===0||annotation_mode" class="btn transparent-btn" @click="previousImage()"><i class="icon icon-back"></i>&nbsp;Back</button>
          <button :disabled="current_image_data.discarded||annotation_mode" class="btn transparent-btn" @click="selectLocation(true)" :class="{'selected-location-btn': current_image_data.location[current_image_data.single_location]===true}"><i class="icon icon-check"></i>&nbsp;Yes</button>
          <button :disabled="current_image_data.discarded||annotation_mode" class="btn transparent-btn" @click="selectLocation(false)" :class="{'selected-location-btn': current_image_data.location[current_image_data.single_location]===false}"><i class="icon icon-cross"></i>&nbsp;No</button>
          <button :disabled="current_image_index>=cached_image_data.length||annotation_mode" class="btn transparent-btn" @click="nextImage()">Next&nbsp;<i class="icon icon-forward"></i></button>
        </div>
        <span class="h3 floating-label">{{current_image_data.single_location}}</span>
      </template>
      
      <div v-if="loading" class="loading loading-lg floating"></div>
      <div id="map"></div>
    </div>
    </div>
  </div>

</window>
<style lang="css">
  body{
    overflow: hidden;
  }
  .centered-panel{
    background-color: #448aff0f;
    width: 100%;
    height: 100%;
    max-height: 400px;
    max-width: 400px;
    left: 50%;
    top: 50%;
    position: absolute;
    -webkit-transform: translate3d(-50%, -50%, 0);
    -moz-transform: translate3d(-50%, -50%, 0);
    transform: translate3d(-50%, -50%, 0);
  }
  .ol-layers:first-child{
    background-color: black;
  }

  .floating-label{
    color:#ffefdbc2;
    position: absolute;
    left: 50%;
    z-index: 999;
    bottom: 40px;
    -webkit-transform: translate3d(-50%, -50%, 0);
    -moz-transform: translate3d(-50%, -50%, 0);
    transform: translate3d(-50%, -50%, 0);
  }
  .floating-switch{
    position: absolute;
    right: 10px;
    z-index: 999;
    top: 30px;
  }

  .floating-channel-btn{
    text-align: left;
    position: absolute;
    left: 5px;
    top: 10px;
    z-index: 666;
  }

  .floating-bottom-btn {
    position: absolute;
    left: calc(50% - 180px);
    bottom: 20px;
    z-index: 999;
  }
  .floating-right-btn{
    position: absolute;
    right: 3px;
    top: 80px;
    width: 330px;
    z-index: 999;
  }
  .floating-left-btn{
    position: absolute;
    left: 3px;
    top: 80px;
    width: 330px;
    z-index: 999;
  }
  .btn{
    width: 90px;
  }
  .location-btn {
    padding-top: 0px;
    font-size: small;
    margin-left: 0px;
    height: 26px;
    flex: none;
    width: 110px;
    background-color:#fff3;
  }
  .location-btn:hover, .location-btn:focus{
    background-color:rgba(255, 255, 255, 0.42);
  }
  .selected-location-btn{
    background-color: #3580ff7d!important;
    color: white!important;
  }
  .transparent-btn, .transparent-btn:focus {
    width: 90px;
    background-color:#fff3;
  }
  .transparent-btn:hover {
    background-color:rgba(255, 255, 255, 0.42);
  }
  .floating {
    position: absolute;
    left: 50%;
    top: 30%;
  }
  #toolbar {
    position: absolute;
    top: 112px;
    left: 10px;
  }
  #toolbar > div:nth-child(1){
    fill: #448aff;
  }

  .ol-layer{
    top: 0px;
  }

  #map{
    max-height: 100%;
    height: 100vh;
    min-height: 100px!important;
  }
  .icon::before {
    position: relative;
  }
  .navbar {
    padding-left: 10px;
  }
  .navbar .navbar-brand {
    font-size: 1.5rem;
    text-decoration: none;
  }
  
  .mouse-position{
    padding-left: 124px;
    padding-top: 10px;
  }
  
  @media all and (max-width: 512px) { /* Change Width Here */
    .hide-on-mobile {
        display: none;
    }
  }
</style>
